"""
Batch Processing Utilities for AUX Protocol.

This module provides optimized batch processing for element queries
and operations to improve performance when dealing with multiple
similar operations.
"""

import asyncio
import logging
from typing import Dict, List, Any, Optional, Union, Tuple
from dataclasses import dataclass
from enum import Enum

from playwright.async_api import Page, Locator

logger = logging.getLogger(__name__)


class BatchOperationType(Enum):
    """Types of batch operations supported."""
    EXTRACT_TEXT = "extract_text"
    EXTRACT_ATTRIBUTE = "extract_attribute"
    EXTRACT_PROPERTY = "extract_property"
    CHECK_VISIBILITY = "check_visibility"
    CHECK_EXISTENCE = "check_existence"
    GET_BOUNDING_BOXES = "get_bounding_boxes"


@dataclass
class BatchQuery:
    """Represents a single query in a batch operation."""
    
    id: str
    selector: str
    operation: BatchOperationType
    params: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.params is None:
            self.params = {}


@dataclass
class BatchResult:
    """Result of a batch query operation."""
    
    query_id: str
    success: bool
    data: Any = None
    error: Optional[str] = None
    element_count: int = 0
    execution_time_ms: Optional[int] = None


class ElementBatchProcessor:
    """
    High-performance batch processor for element operations.
    
    Optimizes multiple element queries by grouping similar operations
    and minimizing DOM traversal overhead.
    """
    
    def __init__(self, page: Page):
        """
        Initialize batch processor for a page.
        
        Args:
            page: Playwright page instance
        """
        self.page = page
        self.logger = logging.getLogger(__name__)
    
    async def execute_batch(self, queries: List[BatchQuery]) -> List[BatchResult]:
        """
        Execute a batch of element queries efficiently.
        
        Args:
            queries: List of batch queries to execute
            
        Returns:
            List of batch results
        """
        if not queries:
            return []
        
        # Group queries by operation type for optimization
        grouped_queries = self._group_queries_by_type(queries)
        results = []
        
        # Execute each group
        for operation_type, query_group in grouped_queries.items():
            if operation_type == BatchOperationType.EXTRACT_TEXT:
                group_results = await self._batch_extract_text(query_group)
            elif operation_type == BatchOperationType.EXTRACT_ATTRIBUTE:
                group_results = await self._batch_extract_attribute(query_group)
            elif operation_type == BatchOperationType.EXTRACT_PROPERTY:
                group_results = await self._batch_extract_property(query_group)
            elif operation_type == BatchOperationType.CHECK_VISIBILITY:
                group_results = await self._batch_check_visibility(query_group)
            elif operation_type == BatchOperationType.CHECK_EXISTENCE:
                group_results = await self._batch_check_existence(query_group)
            elif operation_type == BatchOperationType.GET_BOUNDING_BOXES:
                group_results = await self._batch_get_bounding_boxes(query_group)
            else:
                # Fallback to individual processing
                group_results = await self._process_queries_individually(query_group)
            
            results.extend(group_results)
        
        # Sort results to match original query order
        query_order = {q.id: i for i, q in enumerate(queries)}
        results.sort(key=lambda r: query_order.get(r.query_id, 999999))
        
        return results
    
    def _group_queries_by_type(self, queries: List[BatchQuery]) -> Dict[BatchOperationType, List[BatchQuery]]:\n        \"\"\"\n        Group queries by operation type for batch optimization.\n        \n        Args:\n            queries: List of queries to group\n            \n        Returns:\n            Dictionary mapping operation types to query lists\n        \"\"\"\n        grouped = {}\n        for query in queries:\n            if query.operation not in grouped:\n                grouped[query.operation] = []\n            grouped[query.operation].append(query)\n        return grouped\n    \n    async def _batch_extract_text(self, queries: List[BatchQuery]) -> List[BatchResult]:\n        \"\"\"\n        Batch extract text content from multiple elements.\n        \n        Args:\n            queries: Text extraction queries\n            \n        Returns:\n            List of batch results\n        \"\"\"\n        results = []\n        \n        # Build JavaScript to execute all extractions in one DOM traversal\n        js_code = \"\"\"\n        (() => {\n            const results = [];\n            const selectors = arguments[0];\n            const trim = arguments[1];\n            \n            selectors.forEach((selectorInfo) => {\n                try {\n                    const elements = document.querySelectorAll(selectorInfo.selector);\n                    const texts = [];\n                    \n                    elements.forEach(el => {\n                        let text = el.textContent || '';\n                        if (trim) {\n                            text = text.trim();\n                        }\n                        texts.push(text);\n                    });\n                    \n                    results.push({\n                        id: selectorInfo.id,\n                        success: true,\n                        data: texts,\n                        element_count: elements.length\n                    });\n                } catch (error) {\n                    results.push({\n                        id: selectorInfo.id,\n                        success: false,\n                        error: error.message,\n                        data: [],\n                        element_count: 0\n                    });\n                }\n            });\n            \n            return results;\n        })()\n        \"\"\"\n        \n        # Prepare selector information\n        selector_infos = []\n        for query in queries:\n            selector_infos.append({\n                'id': query.id,\n                'selector': query.selector\n            })\n        \n        trim_whitespace = queries[0].params.get('trim_whitespace', True)\n        \n        try:\n            # Execute batch operation\n            js_results = await self.page.evaluate(js_code, selector_infos, trim_whitespace)\n            \n            # Convert to BatchResult objects\n            for js_result in js_results:\n                result = BatchResult(\n                    query_id=js_result['id'],\n                    success=js_result['success'],\n                    data=js_result['data'],\n                    error=js_result.get('error'),\n                    element_count=js_result['element_count']\n                )\n                results.append(result)\n                \n        except Exception as e:\n            # Fallback to individual processing if batch fails\n            self.logger.warning(f\"Batch text extraction failed, falling back to individual processing: {e}\")\n            results = await self._process_queries_individually(queries)\n        \n        return results\n    \n    async def _batch_extract_attribute(self, queries: List[BatchQuery]) -> List[BatchResult]:\n        \"\"\"\n        Batch extract attributes from multiple elements.\n        \n        Args:\n            queries: Attribute extraction queries\n            \n        Returns:\n            List of batch results\n        \"\"\"\n        results = []\n        \n        # Group by attribute name for further optimization\n        attr_groups = {}\n        for query in queries:\n            attr_name = query.params.get('attribute_name', 'href')\n            if attr_name not in attr_groups:\n                attr_groups[attr_name] = []\n            attr_groups[attr_name].append(query)\n        \n        # Process each attribute group\n        for attr_name, attr_queries in attr_groups.items():\n            js_code = \"\"\"\n            (() => {\n                const results = [];\n                const selectors = arguments[0];\n                const attrName = arguments[1];\n                \n                selectors.forEach((selectorInfo) => {\n                    try {\n                        const elements = document.querySelectorAll(selectorInfo.selector);\n                        const attrs = [];\n                        \n                        elements.forEach(el => {\n                            const attrValue = el.getAttribute(attrName);\n                            attrs.push(attrValue);\n                        });\n                        \n                        results.push({\n                            id: selectorInfo.id,\n                            success: true,\n                            data: attrs,\n                            element_count: elements.length\n                        });\n                    } catch (error) {\n                        results.push({\n                            id: selectorInfo.id,\n                            success: false,\n                            error: error.message,\n                            data: [],\n                            element_count: 0\n                        });\n                    }\n                });\n                \n                return results;\n            })()\n            \"\"\"\n            \n            selector_infos = [{'id': q.id, 'selector': q.selector} for q in attr_queries]\n            \n            try:\n                js_results = await self.page.evaluate(js_code, selector_infos, attr_name)\n                \n                for js_result in js_results:\n                    result = BatchResult(\n                        query_id=js_result['id'],\n                        success=js_result['success'],\n                        data=js_result['data'],\n                        error=js_result.get('error'),\n                        element_count=js_result['element_count']\n                    )\n                    results.append(result)\n                    \n            except Exception as e:\n                self.logger.warning(f\"Batch attribute extraction failed for {attr_name}: {e}\")\n                # Fallback to individual processing\n                individual_results = await self._process_queries_individually(attr_queries)\n                results.extend(individual_results)\n        \n        return results\n    \n    async def _batch_extract_property(self, queries: List[BatchQuery]) -> List[BatchResult]:\n        \"\"\"\n        Batch extract properties from multiple elements.\n        \n        Args:\n            queries: Property extraction queries\n            \n        Returns:\n            List of batch results\n        \"\"\"\n        results = []\n        \n        # Group by property name\n        prop_groups = {}\n        for query in queries:\n            prop_name = query.params.get('property_name', 'value')\n            if prop_name not in prop_groups:\n                prop_groups[prop_name] = []\n            prop_groups[prop_name].append(query)\n        \n        for prop_name, prop_queries in prop_groups.items():\n            js_code = \"\"\"\n            (() => {\n                const results = [];\n                const selectors = arguments[0];\n                const propName = arguments[1];\n                \n                selectors.forEach((selectorInfo) => {\n                    try {\n                        const elements = document.querySelectorAll(selectorInfo.selector);\n                        const props = [];\n                        \n                        elements.forEach(el => {\n                            try {\n                                const propValue = el[propName];\n                                props.push(propValue);\n                            } catch (e) {\n                                props.push(null);\n                            }\n                        });\n                        \n                        results.push({\n                            id: selectorInfo.id,\n                            success: true,\n                            data: props,\n                            element_count: elements.length\n                        });\n                    } catch (error) {\n                        results.push({\n                            id: selectorInfo.id,\n                            success: false,\n                            error: error.message,\n                            data: [],\n                            element_count: 0\n                        });\n                    }\n                });\n                \n                return results;\n            })()\n            \"\"\"\n            \n            selector_infos = [{'id': q.id, 'selector': q.selector} for q in prop_queries]\n            \n            try:\n                js_results = await self.page.evaluate(js_code, selector_infos, prop_name)\n                \n                for js_result in js_results:\n                    result = BatchResult(\n                        query_id=js_result['id'],\n                        success=js_result['success'],\n                        data=js_result['data'],\n                        error=js_result.get('error'),\n                        element_count=js_result['element_count']\n                    )\n                    results.append(result)\n                    \n            except Exception as e:\n                self.logger.warning(f\"Batch property extraction failed for {prop_name}: {e}\")\n                individual_results = await self._process_queries_individually(prop_queries)\n                results.extend(individual_results)\n        \n        return results\n    \n    async def _batch_check_visibility(self, queries: List[BatchQuery]) -> List[BatchResult]:\n        \"\"\"\n        Batch check element visibility.\n        \n        Args:\n            queries: Visibility check queries\n            \n        Returns:\n            List of batch results\n        \"\"\"\n        js_code = \"\"\"\n        (() => {\n            const results = [];\n            const selectors = arguments[0];\n            \n            function isVisible(element) {\n                if (!element) return false;\n                const style = window.getComputedStyle(element);\n                return style.display !== 'none' && \n                       style.visibility !== 'hidden' && \n                       style.opacity !== '0' &&\n                       element.offsetWidth > 0 && \n                       element.offsetHeight > 0;\n            }\n            \n            selectors.forEach((selectorInfo) => {\n                try {\n                    const elements = document.querySelectorAll(selectorInfo.selector);\n                    const visibilityData = [];\n                    \n                    elements.forEach(el => {\n                        visibilityData.push(isVisible(el));\n                    });\n                    \n                    results.push({\n                        id: selectorInfo.id,\n                        success: true,\n                        data: visibilityData,\n                        element_count: elements.length\n                    });\n                } catch (error) {\n                    results.push({\n                        id: selectorInfo.id,\n                        success: false,\n                        error: error.message,\n                        data: [],\n                        element_count: 0\n                    });\n                }\n            });\n            \n            return results;\n        })()\n        \"\"\"\n        \n        selector_infos = [{'id': q.id, 'selector': q.selector} for q in queries]\n        results = []\n        \n        try:\n            js_results = await self.page.evaluate(js_code, selector_infos)\n            \n            for js_result in js_results:\n                result = BatchResult(\n                    query_id=js_result['id'],\n                    success=js_result['success'],\n                    data=js_result['data'],\n                    error=js_result.get('error'),\n                    element_count=js_result['element_count']\n                )\n                results.append(result)\n                \n        except Exception as e:\n            self.logger.warning(f\"Batch visibility check failed: {e}\")\n            results = await self._process_queries_individually(queries)\n        \n        return results\n    \n    async def _batch_check_existence(self, queries: List[BatchQuery]) -> List[BatchResult]:\n        \"\"\"\n        Batch check element existence.\n        \n        Args:\n            queries: Existence check queries\n            \n        Returns:\n            List of batch results\n        \"\"\"\n        js_code = \"\"\"\n        (() => {\n            const results = [];\n            const selectors = arguments[0];\n            \n            selectors.forEach((selectorInfo) => {\n                try {\n                    const elements = document.querySelectorAll(selectorInfo.selector);\n                    \n                    results.push({\n                        id: selectorInfo.id,\n                        success: true,\n                        data: elements.length > 0,\n                        element_count: elements.length\n                    });\n                } catch (error) {\n                    results.push({\n                        id: selectorInfo.id,\n                        success: false,\n                        error: error.message,\n                        data: false,\n                        element_count: 0\n                    });\n                }\n            });\n            \n            return results;\n        })()\n        \"\"\"\n        \n        selector_infos = [{'id': q.id, 'selector': q.selector} for q in queries]\n        results = []\n        \n        try:\n            js_results = await self.page.evaluate(js_code, selector_infos)\n            \n            for js_result in js_results:\n                result = BatchResult(\n                    query_id=js_result['id'],\n                    success=js_result['success'],\n                    data=js_result['data'],\n                    error=js_result.get('error'),\n                    element_count=js_result['element_count']\n                )\n                results.append(result)\n                \n        except Exception as e:\n            self.logger.warning(f\"Batch existence check failed: {e}\")\n            results = await self._process_queries_individually(queries)\n        \n        return results\n    \n    async def _batch_get_bounding_boxes(self, queries: List[BatchQuery]) -> List[BatchResult]:\n        \"\"\"\n        Batch get element bounding boxes.\n        \n        Args:\n            queries: Bounding box queries\n            \n        Returns:\n            List of batch results\n        \"\"\"\n        js_code = \"\"\"\n        (() => {\n            const results = [];\n            const selectors = arguments[0];\n            \n            selectors.forEach((selectorInfo) => {\n                try {\n                    const elements = document.querySelectorAll(selectorInfo.selector);\n                    const boxes = [];\n                    \n                    elements.forEach(el => {\n                        const rect = el.getBoundingClientRect();\n                        boxes.push({\n                            x: rect.x,\n                            y: rect.y,\n                            width: rect.width,\n                            height: rect.height\n                        });\n                    });\n                    \n                    results.push({\n                        id: selectorInfo.id,\n                        success: true,\n                        data: boxes,\n                        element_count: elements.length\n                    });\n                } catch (error) {\n                    results.push({\n                        id: selectorInfo.id,\n                        success: false,\n                        error: error.message,\n                        data: [],\n                        element_count: 0\n                    });\n                }\n            });\n            \n            return results;\n        })()\n        \"\"\"\n        \n        selector_infos = [{'id': q.id, 'selector': q.selector} for q in queries]\n        results = []\n        \n        try:\n            js_results = await self.page.evaluate(js_code, selector_infos)\n            \n            for js_result in js_results:\n                result = BatchResult(\n                    query_id=js_result['id'],\n                    success=js_result['success'],\n                    data=js_result['data'],\n                    error=js_result.get('error'),\n                    element_count=js_result['element_count']\n                )\n                results.append(result)\n                \n        except Exception as e:\n            self.logger.warning(f\"Batch bounding box extraction failed: {e}\")\n            results = await self._process_queries_individually(queries)\n        \n        return results\n    \n    async def _process_queries_individually(self, queries: List[BatchQuery]) -> List[BatchResult]:\n        \"\"\"\n        Fallback to process queries individually.\n        \n        Args:\n            queries: Queries to process\n            \n        Returns:\n            List of batch results\n        \"\"\"\n        results = []\n        \n        for query in queries:\n            try:\n                result = await self._process_single_query(query)\n                results.append(result)\n            except Exception as e:\n                result = BatchResult(\n                    query_id=query.id,\n                    success=False,\n                    error=str(e),\n                    element_count=0\n                )\n                results.append(result)\n        \n        return results\n    \n    async def _process_single_query(self, query: BatchQuery) -> BatchResult:\n        \"\"\"\n        Process a single query using standard Playwright methods.\n        \n        Args:\n            query: Query to process\n            \n        Returns:\n            Batch result\n        \"\"\"\n        locator = self.page.locator(query.selector)\n        element_count = await locator.count()\n        \n        if query.operation == BatchOperationType.EXTRACT_TEXT:\n            if element_count == 0:\n                data = []\n            else:\n                data = []\n                for i in range(element_count):\n                    text = await locator.nth(i).text_content()\n                    if query.params.get('trim_whitespace', True) and text:\n                        text = text.strip()\n                    data.append(text or '')\n        \n        elif query.operation == BatchOperationType.EXTRACT_ATTRIBUTE:\n            attr_name = query.params.get('attribute_name', 'href')\n            data = []\n            for i in range(element_count):\n                attr_value = await locator.nth(i).get_attribute(attr_name)\n                data.append(attr_value)\n        \n        elif query.operation == BatchOperationType.CHECK_VISIBILITY:\n            data = []\n            for i in range(element_count):\n                is_visible = await locator.nth(i).is_visible()\n                data.append(is_visible)\n        \n        elif query.operation == BatchOperationType.CHECK_EXISTENCE:\n            data = element_count > 0\n        \n        else:\n            data = None\n        \n        return BatchResult(\n            query_id=query.id,\n            success=True,\n            data=data,\n            element_count=element_count\n        )\n\n\ndef create_batch_queries_from_selectors(selectors: List[str], \n                                       operation: BatchOperationType,\n                                       params: Dict[str, Any] = None) -> List[BatchQuery]:\n    \"\"\"\n    Create batch queries from a list of selectors.\n    \n    Args:\n        selectors: List of CSS selectors\n        operation: Batch operation type\n        params: Common parameters for all queries\n        \n    Returns:\n        List of batch queries\n    \"\"\"\n    queries = []\n    for i, selector in enumerate(selectors):\n        query = BatchQuery(\n            id=f\"query_{i}\",\n            selector=selector,\n            operation=operation,\n            params=params or {}\n        )\n        queries.append(query)\n    \n    return queries